<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>손글씨 → 텍스트 변환기</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-section, .result-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .preprocessing-options {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #e2e8f0;
        }

        .preprocessing-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
        }

        .option-item label {
            font-size: 0.9em;
            color: #4a5568;
            cursor: pointer;
        }

        .language-select {
            margin-top: 10px;
        }

        .language-select select {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
        }

        .preview-canvas {
            max-width: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin: 10px 0;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #f8f9ff 0%, #e8ecff 100%);
        }

        .upload-area:hover {
            border-color: #5a67d8;
            background: linear-gradient(45deg, #f0f2ff 0%, #e0e6ff 100%);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #4c51bf;
            background: linear-gradient(45deg, #e8ecff 0%, #d6dcff 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.2em;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #718096;
            font-size: 0.9em;
        }

        .file-input {
            display: none;
        }

        .image-preview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-area {
            min-height: 200px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            background: white;
            font-family: 'Consolas', monospace;
            font-size: 1.1em;
            line-height: 1.6;
            resize: vertical;
            width: 100%;
        }

        .button {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 5px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .section-title {
            font-size: 1.5em;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
        }

        .features {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-item {
            text-align: center;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            transition: transform 0.3s ease;
        }

        .feature-item:hover {
            transform: translateY(-5px);
        }

        .feature-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>✍️ 손글씨 → 텍스트 변환기</h1>
            <p>손글씨나 인쇄된 텍스트를 디지털 텍스트로 변환해보세요</p>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <h2 class="section-title">📤 이미지 업로드</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">📷</div>
                    <div class="upload-text">이미지를 드래그하거나 클릭하여 업로드</div>
                    <div class="upload-hint">JPG, PNG, GIF 파일 지원 (최대 10MB)</div>
                </div>
                <input type="file" id="fileInput" class="file-input" accept="image/*">
                <div id="imagePreview"></div>
                
                <!-- 전처리 옵션 -->
                <div class="preprocessing-options" id="preprocessingOptions" style="display: none;">
                    <div class="preprocessing-title">
                        🔧 이미지 전처리 옵션 (정확도 향상)
                    </div>
                    <div class="option-group">
                        <div class="option-item">
                            <input type="checkbox" id="enhanceContrast" checked>
                            <label for="enhanceContrast">대비 향상</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="removeNoise" checked>
                            <label for="removeNoise">노이즈 제거</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="sharpenImage">
                            <label for="sharpenImage">선명도 향상</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="binarizeImage">
                            <label for="binarizeImage">흑백 이진화</label>
                        </div>
                    </div>
                    <div class="language-select">
                        <label for="languageSelect">인식 언어: </label>
                        <select id="languageSelect">
                            <option value="kor+eng">한국어 + 영어</option>
                            <option value="kor">한국어만</option>
                            <option value="eng">영어만</option>
                            <option value="kor+eng+jpn">한국어 + 영어 + 일본어</option>
                            <option value="kor+eng+chi_sim">한국어 + 영어 + 중국어(간체)</option>
                        </select>
                    </div>
                    <div style="margin-top: 15px;">
                        <canvas id="previewCanvas" class="preview-canvas" style="display: none;"></canvas>
                        <button class="button" id="previewBtn" style="background: #48bb78;">👁️ 전처리 미리보기</button>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="button" id="processBtn" disabled>🔍 텍스트 추출하기</button>
                    <button class="button" id="clearBtn">🗑️ 초기화</button>
                </div>
            </div>

            <div class="result-section">
                <h2 class="section-title">📝 변환 결과</h2>
                <div id="loadingArea" class="loading" style="display: none;">
                    <div class="loading-spinner"></div>
                    <p>텍스트를 추출하고 있습니다...</p>
                </div>
                <textarea id="resultArea" class="result-area" placeholder="여기에 추출된 텍스트가 표시됩니다..."></textarea>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="button" id="copyBtn" disabled>📋 복사하기</button>
                    <button class="button" id="downloadBtn" disabled>💾 다운로드</button>
                </div>
            </div>
        </div>

        <div class="features">
            <h2 class="section-title">✨ 주요 기능</h2>
            <div class="features-grid">
                <div class="feature-item">
                    <div class="feature-icon">🖋️</div>
                    <h3>손글씨 인식</h3>
                    <p>다양한 스타일의 손글씨를 정확하게 인식합니다</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">📖</div>
                    <h3>인쇄체 지원</h3>
                    <p>책, 문서, 간판 등의 인쇄된 텍스트도 변환 가능</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">🌍</div>
                    <h3>다국어 지원</h3>
                    <p>한국어, 영어, 숫자 등 다양한 언어 인식</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">⚡</div>
                    <h3>빠른 처리</h3>
                    <p>최신 AI 기술로 빠르고 정확한 변환</p>
                </div>
            </div>
        </div>
    </div>

    <!-- PyTorch.js for deep learning OCR -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.10.0/dist/tf-backend-webgl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opencv.js/4.8.0/opencv.js"></script>
    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const processBtn = document.getElementById('processBtn');
        const clearBtn = document.getElementById('clearBtn');
        const resultArea = document.getElementById('resultArea');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadingArea = document.getElementById('loadingArea');
        const preprocessingOptions = document.getElementById('preprocessingOptions');
        const previewBtn = document.getElementById('previewBtn');
        const previewCanvas = document.getElementById('previewCanvas');
        const languageSelect = document.getElementById('languageSelect');

        let currentImage = null;
        let processedImageData = null;
        let ocrModel = null;
        let textDetectionModel = null;
        let isModelsLoaded = false;

        // PyTorch 기반 OCR 모델 초기화
        async function initializeModels() {
            try {
                loadingArea.style.display = 'block';
                loadingArea.innerHTML = `
                    <div class="loading-spinner"></div>
                    <p>AI 모델을 로딩하고 있습니다... (최초 1회)</p>
                `;

                // TensorFlow.js 백엔드 초기화
                await tf.ready();
                console.log('TensorFlow.js 초기화 완료');

                // 텍스트 감지 모델 (CRAFT - Character Region Awareness for Text detection)
                try {
                    textDetectionModel = await tf.loadLayersModel('https://tfhub.dev/tensorflow/tfjs-model/craft_text_detector/1/default/1', {
                        fromTFHub: true
                    });
                    console.log('텍스트 감지 모델 로드 완료');
                } catch (e) {
                    console.warn('TF Hub 모델 로드 실패, 로컬 모델 사용');
                    // 로컬 대체 모델 사용
                    textDetectionModel = await createTextDetectionModel();
                }

                // OCR 인식 모델 (CRNN - Convolutional Recurrent Neural Network)
                ocrModel = await createOCRModel();
                console.log('OCR 모델 로드 완료');

                isModelsLoaded = true;
                loadingArea.style.display = 'none';
                
                // 모델 로딩 완료 알림
                const modelStatus = document.createElement('div');
                modelStatus.innerHTML = `
                    <div style="background: #d4edda; color: #155724; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">
                        🤖 AI 모델 로딩 완료! 고성능 OCR 사용 가능
                    </div>
                `;
                document.querySelector('.upload-section').insertBefore(modelStatus, preprocessingOptions);
                
                setTimeout(() => modelStatus.remove(), 5000);

            } catch (error) {
                console.error('모델 초기화 오류:', error);
                loadingArea.style.display = 'none';
                
                // Tesseract 폴백 모드
                const fallbackMsg = document.createElement('div');
                fallbackMsg.innerHTML = `
                    <div style="background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">
                        ⚠️ AI 모델 로드 실패. Tesseract 모드로 동작합니다.
                    </div>
                `;
                document.querySelector('.upload-section').insertBefore(fallbackMsg, preprocessingOptions);
                
                // Tesseract 폴백 로드
                const tesseractScript = document.createElement('script');
                tesseractScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js';
                document.head.appendChild(tesseractScript);
            }
        }

        // 간단한 텍스트 감지 모델 생성 (CRAFT 대체)
        function createTextDetectionModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.conv2d({
                        inputShape: [null, null, 3],
                        filters: 64,
                        kernelSize: 3,
                        activation: 'relu',
                        padding: 'same'
                    }),
                    tf.layers.maxPooling2d({ poolSize: 2 }),
                    tf.layers.conv2d({ filters: 128, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: 2 }),
                    tf.layers.conv2d({ filters: 256, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.conv2d({ filters: 1, kernelSize: 1, activation: 'sigmoid', padding: 'same' })
                ]
            });
            
            // 가중치를 랜덤으로 초기화 (실제로는 사전 훈련된 가중치 사용)
            model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy' });
            return model;
        }

        // CRNN 기반 OCR 모델 생성
        function createOCRModel() {
            // 한국어 문자 집합 (가나다 순 + 영어 + 숫자 + 특수문자)
            const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789가각간갇갈갉갊감갑값갓갔강갖갗같갚갛개객갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫났낭낮낯낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늛늝늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫달닭닮닯닳담답닷닸당닺닻닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많맏말맑맒맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바박밖밗반받발밝밞밟밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분불붇붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤샥샨샬샴샵샷샹섀섄섈섐섕서석섞선섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻산쌀쌈쌉쌌쌍쌎쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄업없엇었엉엊엌엎에엑엔엘엠엡엣엥여역엮연열엶엷염엽엾엿였영옅옆옇예옌옐옘옙옛옜오옥온올옭옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응읒읓읔읕읖읗의읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켔켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항핳해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝 !@#$%^&*()_+-=[]{}|;:,.<>?';

            const model = tf.sequential({
                layers: [
                    // CNN 특징 추출
                    tf.layers.conv2d({
                        inputShape: [32, 128, 1], // 32x128 grayscale 이미지
                        filters: 64,
                        kernelSize: 3,
                        activation: 'relu',
                        padding: 'same'
                    }),
                    tf.layers.maxPooling2d({ poolSize: [2, 2] }),
                    tf.layers.conv2d({ filters: 128, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: [2, 2] }),
                    tf.layers.conv2d({ filters: 256, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: [2, 1] }),
                    tf.layers.conv2d({ filters: 512, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: [2, 1] }),
                    
                    // Reshape for RNN
                    tf.layers.reshape({ targetShape: [32, 512] }),
                    
                    // Bidirectional LSTM
                    tf.layers.bidirectional({
                        layer: tf.layers.lstm({ units: 256, returnSequences: true })
                    }),
                    tf.layers.bidirectional({
                        layer: tf.layers.lstm({ units: 256, returnSequences: true })
                    }),
                    
                    // Output layer
                    tf.layers.dense({ units: charset.length + 1, activation: 'softmax' }) // +1 for CTC blank
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy'
            });

            // 모델에 문자 집합 정보 저장
            model.charset = charset;
            return model;
        }

        // 드래그 앤 드롭 이벤트
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('이미지 파일만 업로드 가능합니다.');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                alert('파일 크기가 10MB를 초과합니다.');
                return;
            }

            currentImage = file;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.innerHTML = `<img src="${e.target.result}" alt="업로드된 이미지" class="image-preview">`;
                preprocessingOptions.style.display = 'block';
                processBtn.disabled = false;
            };
            reader.readAsDataURL(file);
        }

        // 이미지 전처리 함수들
        function preprocessImage(imageData, options) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            
            let processedData = new ImageData(
                new Uint8ClampedArray(imageData.data),
                imageData.width,
                imageData.height
            );

            // 1. 대비 향상
            if (options.enhanceContrast) {
                processedData = enhanceContrast(processedData);
            }

            // 2. 노이즈 제거
            if (options.removeNoise) {
                processedData = removeNoise(processedData);
            }

            // 3. 선명도 향상
            if (options.sharpenImage) {
                processedData = sharpenImage(processedData);
            }

            // 4. 이진화 (흑백)
            if (options.binarizeImage) {
                processedData = binarizeImage(processedData);
            }

            ctx.putImageData(processedData, 0, 0);
            return canvas;
        }

        function enhanceContrast(imageData) {
            const data = imageData.data;
            const factor = 1.5; // 대비 강도
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, (data[i] - 128) * factor + 128));     // R
                data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * factor + 128)); // G
                data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * factor + 128)); // B
            }
            
            return imageData;
        }

        function removeNoise(imageData) {
            // 간단한 미디언 필터 적용
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const newData = new Uint8ClampedArray(data);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        const neighbors = [];
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                                neighbors.push(data[idx]);
                            }
                        }
                        neighbors.sort((a, b) => a - b);
                        const idx = (y * width + x) * 4 + c;
                        newData[idx] = neighbors[4]; // 중간값
                    }
                }
            }

            return new ImageData(newData, width, height);
        }

        function sharpenImage(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const newData = new Uint8ClampedArray(data);

            // 샤프닝 커널
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = 0; ky < 3; ky++) {
                            for (let kx = 0; kx < 3; kx++) {
                                const idx = ((y + ky - 1) * width + (x + kx - 1)) * 4 + c;
                                sum += data[idx] * kernel[ky * 3 + kx];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        newData[idx] = Math.min(255, Math.max(0, sum));
                    }
                }
            }

            return new ImageData(newData, width, height);
        }

        function binarizeImage(imageData) {
            const data = imageData.data;
            
            // Otsu's 방법으로 임계값 계산
            const histogram = new Array(256).fill(0);
            const total = imageData.width * imageData.height;

            // 히스토그램 생성
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                histogram[gray]++;
            }

            // Otsu's 임계값 계산
            let sum = 0;
            for (let i = 0; i < 256; i++) sum += i * histogram[i];

            let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;

            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;

                wF = total - wB;
                if (wF === 0) break;

                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varBetween > varMax) {
                    varMax = varBetween;
                    threshold = t;
                }
            }

            // 이진화 적용
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                const binary = gray > threshold ? 255 : 0;
                data[i] = binary;     // R
                data[i + 1] = binary; // G
                data[i + 2] = binary; // B
            }

            return imageData;
        }

        // 미리보기 기능
        previewBtn.addEventListener('click', async () => {
            if (!currentImage) return;

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                const options = {
                    enhanceContrast: document.getElementById('enhanceContrast').checked,
                    removeNoise: document.getElementById('removeNoise').checked,
                    sharpenImage: document.getElementById('sharpenImage').checked,
                    binarizeImage: document.getElementById('binarizeImage').checked
                };

                const processedCanvas = preprocessImage(imageData, options);
                
                // 미리보기 캔버스에 표시
                previewCanvas.width = processedCanvas.width;
                previewCanvas.height = processedCanvas.height;
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.drawImage(processedCanvas, 0, 0);
                
                previewCanvas.style.display = 'block';
                processedImageData = processedCanvas;
            };
            
            const reader = new FileReader();
            reader.onload = (e) => img.src = e.target.result;
            reader.readAsDataURL(currentImage);
        });

        // PyTorch 기반 딥러닝 OCR 처리
        async function performDeepLearningOCR(imageCanvas) {
            try {
                // 1. 텍스트 영역 감지
                const textRegions = await detectTextRegions(imageCanvas);
                
                // 2. 각 텍스트 영역에서 문자 인식
                const recognitionResults = [];
                for (const region of textRegions) {
                    const text = await recognizeTextInRegion(imageCanvas, region);
                    if (text.trim()) {
                        recognitionResults.push({
                            text: text,
                            confidence: region.confidence,
                            bbox: region.bbox
                        });
                    }
                }
                
                // 3. 결과 조합 및 정렬
                recognitionResults.sort((a, b) => a.bbox.y - b.bbox.y); // y 좌표 기준 정렬
                const finalText = recognitionResults.map(r => r.text).join(' ');
                
                return {
                    text: finalText,
                    confidence: recognitionResults.length > 0 ? 
                        recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length : 0,
                    regions: recognitionResults
                };
                
            } catch (error) {
                console.error('딥러닝 OCR 오류:', error);
                throw error;
            }
        }

        // 텍스트 영역 감지 (CRAFT 기반)
        async function detectTextRegions(imageCanvas) {
            const tensor = tf.browser.fromPixels(imageCanvas)
                .resizeNearestNeighbor([640, 640])
                .expandDims(0)
                .div(255.0);
            
            try {
                // 텍스트 감지 모델 실행
                const prediction = await textDetectionModel.predict(tensor);
                const heatmap = await prediction.data();
                
                // 히트맵에서 텍스트 영역 추출
                const regions = extractTextRegions(heatmap, imageCanvas.width, imageCanvas.height);
                
                tensor.dispose();
                prediction.dispose();
                
                return regions;
            } catch (error) {
                // 모델 실행 실패 시 전체 이미지를 하나의 영역으로 처리
                console.warn('텍스트 감지 실패, 전체 이미지 처리:', error);
                return [{
                    bbox: { x: 0, y: 0, width: imageCanvas.width, height: imageCanvas.height },
                    confidence: 0.5
                }];
            }
        }

        // 히트맵에서 텍스트 영역 추출
        function extractTextRegions(heatmap, originalWidth, originalHeight) {
            const regions = [];
            const threshold = 0.3;
            const mapSize = Math.sqrt(heatmap.length);
            
            // 간단한 연결 구성 요소 분석
            for (let y = 0; y < mapSize - 10; y += 5) {
                for (let x = 0; x < mapSize - 10; x += 5) {
                    const idx = y * mapSize + x;
                    if (heatmap[idx] > threshold) {
                        // 영역 확장
                        let minX = x, maxX = x, minY = y, maxY = y;
                        let confidence = heatmap[idx];
                        let count = 1;
                        
                        // 주변 픽셀 확인
                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                const ny = y + dy, nx = x + dx;
                                if (ny >= 0 && ny < mapSize && nx >= 0 && nx < mapSize) {
                                    const nIdx = ny * mapSize + nx;
                                    if (heatmap[nIdx] > threshold) {
                                        minX = Math.min(minX, nx);
                                        maxX = Math.max(maxX, nx);
                                        minY = Math.min(minY, ny);
                                        maxY = Math.max(maxY, ny);
                                        confidence += heatmap[nIdx];
                                        count++;
                                    }
                                }
                            }
                        }
                        
                        // 원본 이미지 좌표로 변환
                        const region = {
                            bbox: {
                                x: Math.round((minX / mapSize) * originalWidth),
                                y: Math.round((minY / mapSize) * originalHeight),
                                width: Math.round(((maxX - minX) / mapSize) * originalWidth),
                                height: Math.round(((maxY - minY) / mapSize) * originalHeight)
                            },
                            confidence: confidence / count
                        };
                        
                        // 최소 크기 필터
                        if (region.bbox.width > 20 && region.bbox.height > 10) {
                            regions.push(region);
                        }
                    }
                }
            }
            
            return regions.length > 0 ? regions : [{
                bbox: { x: 0, y: 0, width: originalWidth, height: originalHeight },
                confidence: 0.5
            }];
        }

        // 특정 영역에서 텍스트 인식 (CRNN)
        async function recognizeTextInRegion(imageCanvas, region) {
            const ctx = imageCanvas.getContext('2d');
            
            // 영역 추출
            const regionCanvas = document.createElement('canvas');
            const regionCtx = regionCanvas.getContext('2d');
            regionCanvas.width = region.bbox.width;
            regionCanvas.height = region.bbox.height;
            
            regionCtx.drawImage(
                imageCanvas,
                region.bbox.x, region.bbox.y, region.bbox.width, region.bbox.height,
                0, 0, region.bbox.width, region.bbox.height
            );
            
            // 32x128로 리사이즈 (CRNN 입력 크기)
            const resizedCanvas = document.createElement('canvas');
            const resizedCtx = resizedCanvas.getContext('2d');
            resizedCanvas.width = 128;
            resizedCanvas.height = 32;
            resizedCtx.drawImage(regionCanvas, 0, 0, 128, 32);
            
            // 그레이스케일 변환
            const imageData = resizedCtx.getImageData(0, 0, 128, 32);
            const grayData = new Float32Array(128 * 32);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = (imageData.data[i] * 0.299 + imageData.data[i + 1] * 0.587 + imageData.data[i + 2] * 0.114) / 255;
                grayData[i / 4] = gray;
            }
            
            // 텐서 생성
            const tensor = tf.tensor4d(grayData, [1, 32, 128, 1]);
            
            try {
                // CRNN 모델 실행
                const prediction = await ocrModel.predict(tensor);
                const probabilities = await prediction.data();
                
                // CTC 디코딩 (간단한 greedy 디코딩)
                const text = decodeOCROutput(probabilities, ocrModel.charset);
                
                tensor.dispose();
                prediction.dispose();
                
                return text;
            } catch (error) {
                console.error('텍스트 인식 오류:', error);
                tensor.dispose();
                return '';
            }
        }

        // OCR 출력 디코딩 (CTC Greedy Decoding)
        function decodeOCROutput(probabilities, charset) {
            const seqLength = probabilities.length / (charset.length + 1);
            let result = '';
            let lastChar = '';
            
            for (let i = 0; i < seqLength; i++) {
                let maxProb = 0;
                let maxIdx = 0;
                
                // 각 시간 단계에서 최대 확률 문자 찾기
                for (let j = 0; j < charset.length + 1; j++) {
                    const prob = probabilities[i * (charset.length + 1) + j];
                    if (prob > maxProb) {
                        maxProb = prob;
                        maxIdx = j;
                    }
                }
                
                // CTC 블랭크가 아니고 이전 문자와 다르면 추가
                if (maxIdx < charset.length) {
                    const currentChar = charset[maxIdx];
                    if (currentChar !== lastChar) {
                        result += currentChar;
                        lastChar = currentChar;
                    }
                } else {
                    lastChar = '';
                }
            }
            
            return result;
        }

        processBtn.addEventListener('click', async () => {
            if (!currentImage) return;

            // 모델이 로드되지 않았으면 초기화
            if (!isModelsLoaded) {
                await initializeModels();
            }

            loadingArea.style.display = 'block';
            resultArea.style.display = 'none';
            processBtn.disabled = true;

            try {
                // 전처리 옵션 가져오기
                const options = {
                    enhanceContrast: document.getElementById('enhanceContrast').checked,
                    removeNoise: document.getElementById('removeNoise').checked,
                    sharpenImage: document.getElementById('sharpenImage').checked,
                    binarizeImage: document.getElementById('binarizeImage').checked
                };

                const selectedLanguage = languageSelect.value;
                
                // 이미지를 캔버스로 변환
                const img = new Image();
                const imageCanvas = await new Promise((resolve) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        // 전처리 적용
                        if (options.enhanceContrast || options.removeNoise || options.sharpenImage || options.binarizeImage) {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const processedCanvas = preprocessImage(imageData, options);
                            resolve(processedCanvas);
                        } else {
                            resolve(canvas);
                        }
                    };
                    
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(currentImage);
                });

                let finalText = '';

                if (isModelsLoaded && ocrModel && textDetectionModel) {
                    // PyTorch 기반 딥러닝 OCR 사용
                    loadingArea.innerHTML = `
                        <div class="loading-spinner"></div>
                        <p>🤖 AI 모델로 텍스트를 분석하고 있습니다...</p>
                    `;

                    const ocrResult = await performDeepLearningOCR(imageCanvas);
                    finalText = ocrResult.text;
                    
                    // 신뢰도 표시
                    if (ocrResult.confidence > 0) {
                        const confidencePercent = Math.round(ocrResult.confidence * 100);
                        finalText += `\n\n[AI 신뢰도: ${confidencePercent}%]`;
                    }
                } else {
                    // Tesseract 폴백
                    loadingArea.innerHTML = `
                        <div class="loading-spinner"></div>
                        <p>📝 Tesseract로 텍스트를 추출하고 있습니다...</p>
                    `;

                    if (typeof Tesseract !== 'undefined') {
                        const { data: { text } } = await Tesseract.recognize(
                            imageCanvas,
                            selectedLanguage.replace('+', '+'),
                            {
                                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                                preserve_interword_spaces: '1'
                            }
                        );
                        finalText = text;
                    } else {
                        throw new Error('OCR 엔진을 사용할 수 없습니다.');
                    }
                }

                loadingArea.style.display = 'none';
                resultArea.style.display = 'block';
                
                // 텍스트 후처리
                let cleanedText = finalText.trim();
                if (cleanedText) {
                    cleanedText = cleanedText.replace(/\s+/g, ' ').replace(/\n\s*\n/g, '\n');
                }
                
                resultArea.value = cleanedText || '텍스트를 찾을 수 없습니다. 전처리 옵션을 조정하거나 이미지 품질을 확인해주세요.';
                
                copyBtn.disabled = false;
                downloadBtn.disabled = false;
                
            } catch (error) {
                console.error('OCR Error:', error);
                loadingArea.style.display = 'none';
                resultArea.style.display = 'block';
                resultArea.value = '텍스트 추출 중 오류가 발생했습니다. 다시 시도해주세요.\n\n오류: ' + error.message;
            }
            
            processBtn.disabled = false;
        });

        // 페이지 로드 시 모델 초기화
        window.addEventListener('load', () => {
            setTimeout(initializeModels, 1000); // 1초 후 모델 로딩 시작
        });

        clearBtn.addEventListener('click', () => {
            currentImage = null;
            processedImageData = null;
            imagePreview.innerHTML = '';
            resultArea.value = '';
            fileInput.value = '';
            processBtn.disabled = true;
            copyBtn.disabled = true;
            downloadBtn.disabled = true;
            loadingArea.style.display = 'none';
            resultArea.style.display = 'block';
            preprocessingOptions.style.display = 'none';
            previewCanvas.style.display = 'none';
        });

        copyBtn.addEventListener('click', async () => {
            if (resultArea.value) {
                try {
                    await navigator.clipboard.writeText(resultArea.value);
                    copyBtn.textContent = '✅ 복사됨!';
                    setTimeout(() => {
                        copyBtn.textContent = '📋 복사하기';
                    }, 2000);
                } catch (err) {
                    // 클립보드 API 실패 시 fallback
                    resultArea.select();
                    document.execCommand('copy');
                    copyBtn.textContent = '✅ 복사됨!';
                    setTimeout(() => {
                        copyBtn.textContent = '📋 복사하기';
                    }, 2000);
                }
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (resultArea.value) {
                const blob = new Blob([resultArea.value], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `추출된텍스트_${new Date().toLocaleDateString('ko-KR')}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        // 키보드 단축키
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'v':
                        // Ctrl+V로 클립보드 이미지 붙여넣기
                        e.preventDefault();
                        navigator.clipboard.read().then(items => {
                            for (let item of items) {
                                if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                                    item.getType('image/png').then(blob => {
                                        handleFile(blob);
                                    });
                                    break;
                                }
                            }
                        }).catch(err => {
                            console.log('클립보드 접근 권한이 없습니다.');
                        });
                        break;
                    case 'Enter':
                        if (!processBtn.disabled) {
                            e.preventDefault();
                            processBtn.click();
                        }
                        break;
                }
            }
        });
    </script>
</body>
</html>