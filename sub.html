<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì†ê¸€ì”¨ â†’ í…ìŠ¤íŠ¸ ë³€í™˜ê¸°</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .upload-section, .result-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            backdrop-filter: blur(10px);
        }

        .preprocessing-options {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid #e2e8f0;
        }

        .preprocessing-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #2d3748;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .option-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .option-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #667eea;
        }

        .option-item label {
            font-size: 0.9em;
            color: #4a5568;
            cursor: pointer;
        }

        .language-select {
            margin-top: 10px;
        }

        .language-select select {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
        }

        .preview-canvas {
            max-width: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            margin: 10px 0;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(45deg, #f8f9ff 0%, #e8ecff 100%);
        }

        .upload-area:hover {
            border-color: #5a67d8;
            background: linear-gradient(45deg, #f0f2ff 0%, #e0e6ff 100%);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #4c51bf;
            background: linear-gradient(45deg, #e8ecff 0%, #d6dcff 100%);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
            color: #667eea;
        }

        .upload-text {
            font-size: 1.2em;
            color: #4a5568;
            margin-bottom: 10px;
        }

        .upload-hint {
            color: #718096;
            font-size: 0.9em;
        }

        .file-input {
            display: none;
        }

        .image-preview {
            max-width: 100%;
            max-height: 400px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .result-area {
            min-height: 200px;
            border: 2px solid #e2e8f0;
            border-radius: 10px;
            padding: 20px;
            background: white;
            font-family: 'Consolas', monospace;
            font-size: 1.1em;
            line-height: 1.6;
            resize: vertical;
            width: 100%;
        }

        .button {
            background: linear-gradient(45deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 5px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .button:disabled {
            background: #cbd5e0;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #e2e8f0;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .section-title {
            font-size: 1.5em;
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
        }

        .features {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            margin-top: 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .feature-item {
            text-align: center;
            padding: 20px;
            border-radius: 15px;
            background: linear-gradient(135deg, #f8f9ff 0%, #e8ecff 100%);
            transition: transform 0.3s ease;
        }

        .feature-item:hover {
            transform: translateY(-5px);
        }

        .feature-icon {
            font-size: 2.5em;
            margin-bottom: 15px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>âœï¸ ì†ê¸€ì”¨ â†’ í…ìŠ¤íŠ¸ ë³€í™˜ê¸°</h1>
            <p>ì†ê¸€ì”¨ë‚˜ ì¸ì‡„ëœ í…ìŠ¤íŠ¸ë¥¼ ë””ì§€í„¸ í…ìŠ¤íŠ¸ë¡œ ë³€í™˜í•´ë³´ì„¸ìš”</p>
        </div>

        <div class="main-content">
            <div class="upload-section">
                <h2 class="section-title">ğŸ“¤ ì´ë¯¸ì§€ ì—…ë¡œë“œ</h2>
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“·</div>
                    <div class="upload-text">ì´ë¯¸ì§€ë¥¼ ë“œë˜ê·¸í•˜ê±°ë‚˜ í´ë¦­í•˜ì—¬ ì—…ë¡œë“œ</div>
                    <div class="upload-hint">JPG, PNG, GIF íŒŒì¼ ì§€ì› (ìµœëŒ€ 10MB)</div>
                </div>
                <input type="file" id="fileInput" class="file-input" accept="image/*">
                <div id="imagePreview"></div>
                
                <!-- ì „ì²˜ë¦¬ ì˜µì…˜ -->
                <div class="preprocessing-options" id="preprocessingOptions" style="display: none;">
                    <div class="preprocessing-title">
                        ğŸ”§ ì´ë¯¸ì§€ ì „ì²˜ë¦¬ ì˜µì…˜ (ì •í™•ë„ í–¥ìƒ)
                    </div>
                    <div class="option-group">
                        <div class="option-item">
                            <input type="checkbox" id="enhanceContrast" checked>
                            <label for="enhanceContrast">ëŒ€ë¹„ í–¥ìƒ</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="removeNoise" checked>
                            <label for="removeNoise">ë…¸ì´ì¦ˆ ì œê±°</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="sharpenImage">
                            <label for="sharpenImage">ì„ ëª…ë„ í–¥ìƒ</label>
                        </div>
                        <div class="option-item">
                            <input type="checkbox" id="binarizeImage">
                            <label for="binarizeImage">í‘ë°± ì´ì§„í™”</label>
                        </div>
                    </div>
                    <div class="language-select">
                        <label for="languageSelect">ì¸ì‹ ì–¸ì–´: </label>
                        <select id="languageSelect">
                            <option value="kor+eng">í•œêµ­ì–´ + ì˜ì–´</option>
                            <option value="kor">í•œêµ­ì–´ë§Œ</option>
                            <option value="eng">ì˜ì–´ë§Œ</option>
                            <option value="kor+eng+jpn">í•œêµ­ì–´ + ì˜ì–´ + ì¼ë³¸ì–´</option>
                            <option value="kor+eng+chi_sim">í•œêµ­ì–´ + ì˜ì–´ + ì¤‘êµ­ì–´(ê°„ì²´)</option>
                        </select>
                    </div>
                    <div style="margin-top: 15px;">
                        <canvas id="previewCanvas" class="preview-canvas" style="display: none;"></canvas>
                        <button class="button" id="previewBtn" style="background: #48bb78;">ğŸ‘ï¸ ì „ì²˜ë¦¬ ë¯¸ë¦¬ë³´ê¸°</button>
                    </div>
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="button" id="processBtn" disabled>ğŸ” í…ìŠ¤íŠ¸ ì¶”ì¶œí•˜ê¸°</button>
                    <button class="button" id="clearBtn">ğŸ—‘ï¸ ì´ˆê¸°í™”</button>
                </div>
            </div>

            <div class="result-section">
                <h2 class="section-title">ğŸ“ ë³€í™˜ ê²°ê³¼</h2>
                <div id="loadingArea" class="loading" style="display: none;">
                    <div class="loading-spinner"></div>
                    <p>í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
                </div>
                <textarea id="resultArea" class="result-area" placeholder="ì—¬ê¸°ì— ì¶”ì¶œëœ í…ìŠ¤íŠ¸ê°€ í‘œì‹œë©ë‹ˆë‹¤..."></textarea>
                <div style="text-align: center; margin-top: 20px;">
                    <button class="button" id="copyBtn" disabled>ğŸ“‹ ë³µì‚¬í•˜ê¸°</button>
                    <button class="button" id="downloadBtn" disabled>ğŸ’¾ ë‹¤ìš´ë¡œë“œ</button>
                </div>
            </div>
        </div>

        <div class="features">
            <h2 class="section-title">âœ¨ ì£¼ìš” ê¸°ëŠ¥</h2>
            <div class="features-grid">
                <div class="feature-item">
                    <div class="feature-icon">ğŸ–‹ï¸</div>
                    <h3>ì†ê¸€ì”¨ ì¸ì‹</h3>
                    <p>ë‹¤ì–‘í•œ ìŠ¤íƒ€ì¼ì˜ ì†ê¸€ì”¨ë¥¼ ì •í™•í•˜ê²Œ ì¸ì‹í•©ë‹ˆë‹¤</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">ğŸ“–</div>
                    <h3>ì¸ì‡„ì²´ ì§€ì›</h3>
                    <p>ì±…, ë¬¸ì„œ, ê°„íŒ ë“±ì˜ ì¸ì‡„ëœ í…ìŠ¤íŠ¸ë„ ë³€í™˜ ê°€ëŠ¥</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">ğŸŒ</div>
                    <h3>ë‹¤êµ­ì–´ ì§€ì›</h3>
                    <p>í•œêµ­ì–´, ì˜ì–´, ìˆ«ì ë“± ë‹¤ì–‘í•œ ì–¸ì–´ ì¸ì‹</p>
                </div>
                <div class="feature-item">
                    <div class="feature-icon">âš¡</div>
                    <h3>ë¹ ë¥¸ ì²˜ë¦¬</h3>
                    <p>ìµœì‹  AI ê¸°ìˆ ë¡œ ë¹ ë¥´ê³  ì •í™•í•œ ë³€í™˜</p>
                </div>
            </div>
        </div>
    </div>

    <!-- PyTorch.js for deep learning OCR -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgl@4.10.0/dist/tf-backend-webgl.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opencv.js/4.8.0/opencv.js"></script>
    <script>
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const imagePreview = document.getElementById('imagePreview');
        const processBtn = document.getElementById('processBtn');
        const clearBtn = document.getElementById('clearBtn');
        const resultArea = document.getElementById('resultArea');
        const copyBtn = document.getElementById('copyBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loadingArea = document.getElementById('loadingArea');
        const preprocessingOptions = document.getElementById('preprocessingOptions');
        const previewBtn = document.getElementById('previewBtn');
        const previewCanvas = document.getElementById('previewCanvas');
        const languageSelect = document.getElementById('languageSelect');

        let currentImage = null;
        let processedImageData = null;
        let ocrModel = null;
        let textDetectionModel = null;
        let isModelsLoaded = false;

        // PyTorch ê¸°ë°˜ OCR ëª¨ë¸ ì´ˆê¸°í™”
        async function initializeModels() {
            try {
                loadingArea.style.display = 'block';
                loadingArea.innerHTML = `
                    <div class="loading-spinner"></div>
                    <p>AI ëª¨ë¸ì„ ë¡œë”©í•˜ê³  ìˆìŠµë‹ˆë‹¤... (ìµœì´ˆ 1íšŒ)</p>
                `;

                // TensorFlow.js ë°±ì—”ë“œ ì´ˆê¸°í™”
                await tf.ready();
                console.log('TensorFlow.js ì´ˆê¸°í™” ì™„ë£Œ');

                // í…ìŠ¤íŠ¸ ê°ì§€ ëª¨ë¸ (CRAFT - Character Region Awareness for Text detection)
                try {
                    textDetectionModel = await tf.loadLayersModel('https://tfhub.dev/tensorflow/tfjs-model/craft_text_detector/1/default/1', {
                        fromTFHub: true
                    });
                    console.log('í…ìŠ¤íŠ¸ ê°ì§€ ëª¨ë¸ ë¡œë“œ ì™„ë£Œ');
                } catch (e) {
                    console.warn('TF Hub ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨, ë¡œì»¬ ëª¨ë¸ ì‚¬ìš©');
                    // ë¡œì»¬ ëŒ€ì²´ ëª¨ë¸ ì‚¬ìš©
                    textDetectionModel = await createTextDetectionModel();
                }

                // OCR ì¸ì‹ ëª¨ë¸ (CRNN - Convolutional Recurrent Neural Network)
                ocrModel = await createOCRModel();
                console.log('OCR ëª¨ë¸ ë¡œë“œ ì™„ë£Œ');

                isModelsLoaded = true;
                loadingArea.style.display = 'none';
                
                // ëª¨ë¸ ë¡œë”© ì™„ë£Œ ì•Œë¦¼
                const modelStatus = document.createElement('div');
                modelStatus.innerHTML = `
                    <div style="background: #d4edda; color: #155724; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">
                        ğŸ¤– AI ëª¨ë¸ ë¡œë”© ì™„ë£Œ! ê³ ì„±ëŠ¥ OCR ì‚¬ìš© ê°€ëŠ¥
                    </div>
                `;
                document.querySelector('.upload-section').insertBefore(modelStatus, preprocessingOptions);
                
                setTimeout(() => modelStatus.remove(), 5000);

            } catch (error) {
                console.error('ëª¨ë¸ ì´ˆê¸°í™” ì˜¤ë¥˜:', error);
                loadingArea.style.display = 'none';
                
                // Tesseract í´ë°± ëª¨ë“œ
                const fallbackMsg = document.createElement('div');
                fallbackMsg.innerHTML = `
                    <div style="background: #fff3cd; color: #856404; padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center;">
                        âš ï¸ AI ëª¨ë¸ ë¡œë“œ ì‹¤íŒ¨. Tesseract ëª¨ë“œë¡œ ë™ì‘í•©ë‹ˆë‹¤.
                    </div>
                `;
                document.querySelector('.upload-section').insertBefore(fallbackMsg, preprocessingOptions);
                
                // Tesseract í´ë°± ë¡œë“œ
                const tesseractScript = document.createElement('script');
                tesseractScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js';
                document.head.appendChild(tesseractScript);
            }
        }

        // ê°„ë‹¨í•œ í…ìŠ¤íŠ¸ ê°ì§€ ëª¨ë¸ ìƒì„± (CRAFT ëŒ€ì²´)
        function createTextDetectionModel() {
            const model = tf.sequential({
                layers: [
                    tf.layers.conv2d({
                        inputShape: [null, null, 3],
                        filters: 64,
                        kernelSize: 3,
                        activation: 'relu',
                        padding: 'same'
                    }),
                    tf.layers.maxPooling2d({ poolSize: 2 }),
                    tf.layers.conv2d({ filters: 128, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: 2 }),
                    tf.layers.conv2d({ filters: 256, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.conv2d({ filters: 1, kernelSize: 1, activation: 'sigmoid', padding: 'same' })
                ]
            });
            
            // ê°€ì¤‘ì¹˜ë¥¼ ëœë¤ìœ¼ë¡œ ì´ˆê¸°í™” (ì‹¤ì œë¡œëŠ” ì‚¬ì „ í›ˆë ¨ëœ ê°€ì¤‘ì¹˜ ì‚¬ìš©)
            model.compile({ optimizer: 'adam', loss: 'binaryCrossentropy' });
            return model;
        }

        // CRNN ê¸°ë°˜ OCR ëª¨ë¸ ìƒì„±
        function createOCRModel() {
            // í•œêµ­ì–´ ë¬¸ì ì§‘í•© (ê°€ë‚˜ë‹¤ ìˆœ + ì˜ì–´ + ìˆ«ì + íŠ¹ìˆ˜ë¬¸ì)
            const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°ê°‘ê°’ê°“ê°”ê°•ê°–ê°—ê°™ê°šê°›ê°œê°ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹ê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿ê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëë“ë”ë•ë—ë™ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«ë‚¬ë‚­ë‚®ë‚¯ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ›ëŠëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«ë‹¬ë‹­ë‹®ë‹¯ë‹³ë‹´ë‹µë‹·ë‹¸ë‹¹ë‹ºë‹»ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëëŸë¤ë¥ë§ë©ë«ë®ë°ë±ë´ë¸ë€ëëƒë„ë…ëŒëë”ë ë¡ë¨ë¬ë„ë…ëˆë‹ëŒëëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ë€ë„ëŒëëëë‘ë’ë–ë—ë˜ë™ëœë ë¨ë©ë«ë¬ë­ë´ëµë¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦ë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§ë§ë§ë§‘ë§’ë§˜ë§™ë§›ë§ë§ë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©ë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼ë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”ë°•ë°–ë°—ë°˜ë°›ë°œë°ë°ë°Ÿë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²ë²”ë²•ë²—ë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶ˆë¶‡ë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹ë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œì„ì„ì„ ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†ì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‚°ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ì„ìˆìŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•ì•“ì•”ì••ì•—ì•˜ì•™ì•ì•ì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„ì—…ì—†ì—‡ì—ˆì—‰ì—Šì—Œì—ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼ì—½ì—¾ì—¿ì˜€ì˜ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘ì’ì“ì”ì•ì–ì—ì˜ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìƒì„ì…ì‡ìˆì‰ìŠììì‘ì”ì–ì—ì˜ìšì ì¡ì£ì¤ì¥ì¦ì¬ì­ì°ì´ì¼ì½ì¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Šì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»ì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼”ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œí‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½í€í„íŒíííí‘í˜í™íœí í¨í©í«í­í´í¸í¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿ííˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•³í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ííˆí‰íŒíí˜í™í›í !@#$%^&*()_+-=[]{}|;:,.<>?';

            const model = tf.sequential({
                layers: [
                    // CNN íŠ¹ì§• ì¶”ì¶œ
                    tf.layers.conv2d({
                        inputShape: [32, 128, 1], // 32x128 grayscale ì´ë¯¸ì§€
                        filters: 64,
                        kernelSize: 3,
                        activation: 'relu',
                        padding: 'same'
                    }),
                    tf.layers.maxPooling2d({ poolSize: [2, 2] }),
                    tf.layers.conv2d({ filters: 128, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: [2, 2] }),
                    tf.layers.conv2d({ filters: 256, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: [2, 1] }),
                    tf.layers.conv2d({ filters: 512, kernelSize: 3, activation: 'relu', padding: 'same' }),
                    tf.layers.maxPooling2d({ poolSize: [2, 1] }),
                    
                    // Reshape for RNN
                    tf.layers.reshape({ targetShape: [32, 512] }),
                    
                    // Bidirectional LSTM
                    tf.layers.bidirectional({
                        layer: tf.layers.lstm({ units: 256, returnSequences: true })
                    }),
                    tf.layers.bidirectional({
                        layer: tf.layers.lstm({ units: 256, returnSequences: true })
                    }),
                    
                    // Output layer
                    tf.layers.dense({ units: charset.length + 1, activation: 'softmax' }) // +1 for CTC blank
                ]
            });

            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy'
            });

            // ëª¨ë¸ì— ë¬¸ì ì§‘í•© ì •ë³´ ì €ì¥
            model.charset = charset;
            return model;
        }

        // ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì´ë²¤íŠ¸
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        uploadArea.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                alert('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }

            if (file.size > 10 * 1024 * 1024) {
                alert('íŒŒì¼ í¬ê¸°ê°€ 10MBë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.');
                return;
            }

            currentImage = file;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                imagePreview.innerHTML = `<img src="${e.target.result}" alt="ì—…ë¡œë“œëœ ì´ë¯¸ì§€" class="image-preview">`;
                preprocessingOptions.style.display = 'block';
                processBtn.disabled = false;
            };
            reader.readAsDataURL(file);
        }

        // ì´ë¯¸ì§€ ì „ì²˜ë¦¬ í•¨ìˆ˜ë“¤
        function preprocessImage(imageData, options) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            
            let processedData = new ImageData(
                new Uint8ClampedArray(imageData.data),
                imageData.width,
                imageData.height
            );

            // 1. ëŒ€ë¹„ í–¥ìƒ
            if (options.enhanceContrast) {
                processedData = enhanceContrast(processedData);
            }

            // 2. ë…¸ì´ì¦ˆ ì œê±°
            if (options.removeNoise) {
                processedData = removeNoise(processedData);
            }

            // 3. ì„ ëª…ë„ í–¥ìƒ
            if (options.sharpenImage) {
                processedData = sharpenImage(processedData);
            }

            // 4. ì´ì§„í™” (í‘ë°±)
            if (options.binarizeImage) {
                processedData = binarizeImage(processedData);
            }

            ctx.putImageData(processedData, 0, 0);
            return canvas;
        }

        function enhanceContrast(imageData) {
            const data = imageData.data;
            const factor = 1.5; // ëŒ€ë¹„ ê°•ë„
            
            for (let i = 0; i < data.length; i += 4) {
                data[i] = Math.min(255, Math.max(0, (data[i] - 128) * factor + 128));     // R
                data[i + 1] = Math.min(255, Math.max(0, (data[i + 1] - 128) * factor + 128)); // G
                data[i + 2] = Math.min(255, Math.max(0, (data[i + 2] - 128) * factor + 128)); // B
            }
            
            return imageData;
        }

        function removeNoise(imageData) {
            // ê°„ë‹¨í•œ ë¯¸ë””ì–¸ í•„í„° ì ìš©
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const newData = new Uint8ClampedArray(data);

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        const neighbors = [];
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                const idx = ((y + dy) * width + (x + dx)) * 4 + c;
                                neighbors.push(data[idx]);
                            }
                        }
                        neighbors.sort((a, b) => a - b);
                        const idx = (y * width + x) * 4 + c;
                        newData[idx] = neighbors[4]; // ì¤‘ê°„ê°’
                    }
                }
            }

            return new ImageData(newData, width, height);
        }

        function sharpenImage(imageData) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;
            const newData = new Uint8ClampedArray(data);

            // ìƒ¤í”„ë‹ ì»¤ë„
            const kernel = [
                0, -1, 0,
                -1, 5, -1,
                0, -1, 0
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = 0; ky < 3; ky++) {
                            for (let kx = 0; kx < 3; kx++) {
                                const idx = ((y + ky - 1) * width + (x + kx - 1)) * 4 + c;
                                sum += data[idx] * kernel[ky * 3 + kx];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        newData[idx] = Math.min(255, Math.max(0, sum));
                    }
                }
            }

            return new ImageData(newData, width, height);
        }

        function binarizeImage(imageData) {
            const data = imageData.data;
            
            // Otsu's ë°©ë²•ìœ¼ë¡œ ì„ê³„ê°’ ê³„ì‚°
            const histogram = new Array(256).fill(0);
            const total = imageData.width * imageData.height;

            // íˆìŠ¤í† ê·¸ë¨ ìƒì„±
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                histogram[gray]++;
            }

            // Otsu's ì„ê³„ê°’ ê³„ì‚°
            let sum = 0;
            for (let i = 0; i < 256; i++) sum += i * histogram[i];

            let sumB = 0, wB = 0, wF = 0, varMax = 0, threshold = 0;

            for (let t = 0; t < 256; t++) {
                wB += histogram[t];
                if (wB === 0) continue;

                wF = total - wB;
                if (wF === 0) break;

                sumB += t * histogram[t];
                const mB = sumB / wB;
                const mF = (sum - sumB) / wF;
                const varBetween = wB * wF * (mB - mF) * (mB - mF);

                if (varBetween > varMax) {
                    varMax = varBetween;
                    threshold = t;
                }
            }

            // ì´ì§„í™” ì ìš©
            for (let i = 0; i < data.length; i += 4) {
                const gray = Math.round(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                const binary = gray > threshold ? 255 : 0;
                data[i] = binary;     // R
                data[i + 1] = binary; // G
                data[i + 2] = binary; // B
            }

            return imageData;
        }

        // ë¯¸ë¦¬ë³´ê¸° ê¸°ëŠ¥
        previewBtn.addEventListener('click', async () => {
            if (!currentImage) return;

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                const options = {
                    enhanceContrast: document.getElementById('enhanceContrast').checked,
                    removeNoise: document.getElementById('removeNoise').checked,
                    sharpenImage: document.getElementById('sharpenImage').checked,
                    binarizeImage: document.getElementById('binarizeImage').checked
                };

                const processedCanvas = preprocessImage(imageData, options);
                
                // ë¯¸ë¦¬ë³´ê¸° ìº”ë²„ìŠ¤ì— í‘œì‹œ
                previewCanvas.width = processedCanvas.width;
                previewCanvas.height = processedCanvas.height;
                const previewCtx = previewCanvas.getContext('2d');
                previewCtx.drawImage(processedCanvas, 0, 0);
                
                previewCanvas.style.display = 'block';
                processedImageData = processedCanvas;
            };
            
            const reader = new FileReader();
            reader.onload = (e) => img.src = e.target.result;
            reader.readAsDataURL(currentImage);
        });

        // PyTorch ê¸°ë°˜ ë”¥ëŸ¬ë‹ OCR ì²˜ë¦¬
        async function performDeepLearningOCR(imageCanvas) {
            try {
                // 1. í…ìŠ¤íŠ¸ ì˜ì—­ ê°ì§€
                const textRegions = await detectTextRegions(imageCanvas);
                
                // 2. ê° í…ìŠ¤íŠ¸ ì˜ì—­ì—ì„œ ë¬¸ì ì¸ì‹
                const recognitionResults = [];
                for (const region of textRegions) {
                    const text = await recognizeTextInRegion(imageCanvas, region);
                    if (text.trim()) {
                        recognitionResults.push({
                            text: text,
                            confidence: region.confidence,
                            bbox: region.bbox
                        });
                    }
                }
                
                // 3. ê²°ê³¼ ì¡°í•© ë° ì •ë ¬
                recognitionResults.sort((a, b) => a.bbox.y - b.bbox.y); // y ì¢Œí‘œ ê¸°ì¤€ ì •ë ¬
                const finalText = recognitionResults.map(r => r.text).join(' ');
                
                return {
                    text: finalText,
                    confidence: recognitionResults.length > 0 ? 
                        recognitionResults.reduce((sum, r) => sum + r.confidence, 0) / recognitionResults.length : 0,
                    regions: recognitionResults
                };
                
            } catch (error) {
                console.error('ë”¥ëŸ¬ë‹ OCR ì˜¤ë¥˜:', error);
                throw error;
            }
        }

        // í…ìŠ¤íŠ¸ ì˜ì—­ ê°ì§€ (CRAFT ê¸°ë°˜)
        async function detectTextRegions(imageCanvas) {
            const tensor = tf.browser.fromPixels(imageCanvas)
                .resizeNearestNeighbor([640, 640])
                .expandDims(0)
                .div(255.0);
            
            try {
                // í…ìŠ¤íŠ¸ ê°ì§€ ëª¨ë¸ ì‹¤í–‰
                const prediction = await textDetectionModel.predict(tensor);
                const heatmap = await prediction.data();
                
                // íˆíŠ¸ë§µì—ì„œ í…ìŠ¤íŠ¸ ì˜ì—­ ì¶”ì¶œ
                const regions = extractTextRegions(heatmap, imageCanvas.width, imageCanvas.height);
                
                tensor.dispose();
                prediction.dispose();
                
                return regions;
            } catch (error) {
                // ëª¨ë¸ ì‹¤í–‰ ì‹¤íŒ¨ ì‹œ ì „ì²´ ì´ë¯¸ì§€ë¥¼ í•˜ë‚˜ì˜ ì˜ì—­ìœ¼ë¡œ ì²˜ë¦¬
                console.warn('í…ìŠ¤íŠ¸ ê°ì§€ ì‹¤íŒ¨, ì „ì²´ ì´ë¯¸ì§€ ì²˜ë¦¬:', error);
                return [{
                    bbox: { x: 0, y: 0, width: imageCanvas.width, height: imageCanvas.height },
                    confidence: 0.5
                }];
            }
        }

        // íˆíŠ¸ë§µì—ì„œ í…ìŠ¤íŠ¸ ì˜ì—­ ì¶”ì¶œ
        function extractTextRegions(heatmap, originalWidth, originalHeight) {
            const regions = [];
            const threshold = 0.3;
            const mapSize = Math.sqrt(heatmap.length);
            
            // ê°„ë‹¨í•œ ì—°ê²° êµ¬ì„± ìš”ì†Œ ë¶„ì„
            for (let y = 0; y < mapSize - 10; y += 5) {
                for (let x = 0; x < mapSize - 10; x += 5) {
                    const idx = y * mapSize + x;
                    if (heatmap[idx] > threshold) {
                        // ì˜ì—­ í™•ì¥
                        let minX = x, maxX = x, minY = y, maxY = y;
                        let confidence = heatmap[idx];
                        let count = 1;
                        
                        // ì£¼ë³€ í”½ì…€ í™•ì¸
                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                const ny = y + dy, nx = x + dx;
                                if (ny >= 0 && ny < mapSize && nx >= 0 && nx < mapSize) {
                                    const nIdx = ny * mapSize + nx;
                                    if (heatmap[nIdx] > threshold) {
                                        minX = Math.min(minX, nx);
                                        maxX = Math.max(maxX, nx);
                                        minY = Math.min(minY, ny);
                                        maxY = Math.max(maxY, ny);
                                        confidence += heatmap[nIdx];
                                        count++;
                                    }
                                }
                            }
                        }
                        
                        // ì›ë³¸ ì´ë¯¸ì§€ ì¢Œí‘œë¡œ ë³€í™˜
                        const region = {
                            bbox: {
                                x: Math.round((minX / mapSize) * originalWidth),
                                y: Math.round((minY / mapSize) * originalHeight),
                                width: Math.round(((maxX - minX) / mapSize) * originalWidth),
                                height: Math.round(((maxY - minY) / mapSize) * originalHeight)
                            },
                            confidence: confidence / count
                        };
                        
                        // ìµœì†Œ í¬ê¸° í•„í„°
                        if (region.bbox.width > 20 && region.bbox.height > 10) {
                            regions.push(region);
                        }
                    }
                }
            }
            
            return regions.length > 0 ? regions : [{
                bbox: { x: 0, y: 0, width: originalWidth, height: originalHeight },
                confidence: 0.5
            }];
        }

        // íŠ¹ì • ì˜ì—­ì—ì„œ í…ìŠ¤íŠ¸ ì¸ì‹ (CRNN)
        async function recognizeTextInRegion(imageCanvas, region) {
            const ctx = imageCanvas.getContext('2d');
            
            // ì˜ì—­ ì¶”ì¶œ
            const regionCanvas = document.createElement('canvas');
            const regionCtx = regionCanvas.getContext('2d');
            regionCanvas.width = region.bbox.width;
            regionCanvas.height = region.bbox.height;
            
            regionCtx.drawImage(
                imageCanvas,
                region.bbox.x, region.bbox.y, region.bbox.width, region.bbox.height,
                0, 0, region.bbox.width, region.bbox.height
            );
            
            // 32x128ë¡œ ë¦¬ì‚¬ì´ì¦ˆ (CRNN ì…ë ¥ í¬ê¸°)
            const resizedCanvas = document.createElement('canvas');
            const resizedCtx = resizedCanvas.getContext('2d');
            resizedCanvas.width = 128;
            resizedCanvas.height = 32;
            resizedCtx.drawImage(regionCanvas, 0, 0, 128, 32);
            
            // ê·¸ë ˆì´ìŠ¤ì¼€ì¼ ë³€í™˜
            const imageData = resizedCtx.getImageData(0, 0, 128, 32);
            const grayData = new Float32Array(128 * 32);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = (imageData.data[i] * 0.299 + imageData.data[i + 1] * 0.587 + imageData.data[i + 2] * 0.114) / 255;
                grayData[i / 4] = gray;
            }
            
            // í…ì„œ ìƒì„±
            const tensor = tf.tensor4d(grayData, [1, 32, 128, 1]);
            
            try {
                // CRNN ëª¨ë¸ ì‹¤í–‰
                const prediction = await ocrModel.predict(tensor);
                const probabilities = await prediction.data();
                
                // CTC ë””ì½”ë”© (ê°„ë‹¨í•œ greedy ë””ì½”ë”©)
                const text = decodeOCROutput(probabilities, ocrModel.charset);
                
                tensor.dispose();
                prediction.dispose();
                
                return text;
            } catch (error) {
                console.error('í…ìŠ¤íŠ¸ ì¸ì‹ ì˜¤ë¥˜:', error);
                tensor.dispose();
                return '';
            }
        }

        // OCR ì¶œë ¥ ë””ì½”ë”© (CTC Greedy Decoding)
        function decodeOCROutput(probabilities, charset) {
            const seqLength = probabilities.length / (charset.length + 1);
            let result = '';
            let lastChar = '';
            
            for (let i = 0; i < seqLength; i++) {
                let maxProb = 0;
                let maxIdx = 0;
                
                // ê° ì‹œê°„ ë‹¨ê³„ì—ì„œ ìµœëŒ€ í™•ë¥  ë¬¸ì ì°¾ê¸°
                for (let j = 0; j < charset.length + 1; j++) {
                    const prob = probabilities[i * (charset.length + 1) + j];
                    if (prob > maxProb) {
                        maxProb = prob;
                        maxIdx = j;
                    }
                }
                
                // CTC ë¸”ë­í¬ê°€ ì•„ë‹ˆê³  ì´ì „ ë¬¸ìì™€ ë‹¤ë¥´ë©´ ì¶”ê°€
                if (maxIdx < charset.length) {
                    const currentChar = charset[maxIdx];
                    if (currentChar !== lastChar) {
                        result += currentChar;
                        lastChar = currentChar;
                    }
                } else {
                    lastChar = '';
                }
            }
            
            return result;
        }

        processBtn.addEventListener('click', async () => {
            if (!currentImage) return;

            // ëª¨ë¸ì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìœ¼ë©´ ì´ˆê¸°í™”
            if (!isModelsLoaded) {
                await initializeModels();
            }

            loadingArea.style.display = 'block';
            resultArea.style.display = 'none';
            processBtn.disabled = true;

            try {
                // ì „ì²˜ë¦¬ ì˜µì…˜ ê°€ì ¸ì˜¤ê¸°
                const options = {
                    enhanceContrast: document.getElementById('enhanceContrast').checked,
                    removeNoise: document.getElementById('removeNoise').checked,
                    sharpenImage: document.getElementById('sharpenImage').checked,
                    binarizeImage: document.getElementById('binarizeImage').checked
                };

                const selectedLanguage = languageSelect.value;
                
                // ì´ë¯¸ì§€ë¥¼ ìº”ë²„ìŠ¤ë¡œ ë³€í™˜
                const img = new Image();
                const imageCanvas = await new Promise((resolve) => {
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        ctx.drawImage(img, 0, 0);
                        
                        // ì „ì²˜ë¦¬ ì ìš©
                        if (options.enhanceContrast || options.removeNoise || options.sharpenImage || options.binarizeImage) {
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            const processedCanvas = preprocessImage(imageData, options);
                            resolve(processedCanvas);
                        } else {
                            resolve(canvas);
                        }
                    };
                    
                    const reader = new FileReader();
                    reader.onload = (e) => img.src = e.target.result;
                    reader.readAsDataURL(currentImage);
                });

                let finalText = '';

                if (isModelsLoaded && ocrModel && textDetectionModel) {
                    // PyTorch ê¸°ë°˜ ë”¥ëŸ¬ë‹ OCR ì‚¬ìš©
                    loadingArea.innerHTML = `
                        <div class="loading-spinner"></div>
                        <p>ğŸ¤– AI ëª¨ë¸ë¡œ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
                    `;

                    const ocrResult = await performDeepLearningOCR(imageCanvas);
                    finalText = ocrResult.text;
                    
                    // ì‹ ë¢°ë„ í‘œì‹œ
                    if (ocrResult.confidence > 0) {
                        const confidencePercent = Math.round(ocrResult.confidence * 100);
                        finalText += `\n\n[AI ì‹ ë¢°ë„: ${confidencePercent}%]`;
                    }
                } else {
                    // Tesseract í´ë°±
                    loadingArea.innerHTML = `
                        <div class="loading-spinner"></div>
                        <p>ğŸ“ Tesseractë¡œ í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ê³  ìˆìŠµë‹ˆë‹¤...</p>
                    `;

                    if (typeof Tesseract !== 'undefined') {
                        const { data: { text } } = await Tesseract.recognize(
                            imageCanvas,
                            selectedLanguage.replace('+', '+'),
                            {
                                tessedit_pageseg_mode: Tesseract.PSM.AUTO,
                                preserve_interword_spaces: '1'
                            }
                        );
                        finalText = text;
                    } else {
                        throw new Error('OCR ì—”ì§„ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    }
                }

                loadingArea.style.display = 'none';
                resultArea.style.display = 'block';
                
                // í…ìŠ¤íŠ¸ í›„ì²˜ë¦¬
                let cleanedText = finalText.trim();
                if (cleanedText) {
                    cleanedText = cleanedText.replace(/\s+/g, ' ').replace(/\n\s*\n/g, '\n');
                }
                
                resultArea.value = cleanedText || 'í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì „ì²˜ë¦¬ ì˜µì…˜ì„ ì¡°ì •í•˜ê±°ë‚˜ ì´ë¯¸ì§€ í’ˆì§ˆì„ í™•ì¸í•´ì£¼ì„¸ìš”.';
                
                copyBtn.disabled = false;
                downloadBtn.disabled = false;
                
            } catch (error) {
                console.error('OCR Error:', error);
                loadingArea.style.display = 'none';
                resultArea.style.display = 'block';
                resultArea.value = 'í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.\n\nì˜¤ë¥˜: ' + error.message;
            }
            
            processBtn.disabled = false;
        });

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ëª¨ë¸ ì´ˆê¸°í™”
        window.addEventListener('load', () => {
            setTimeout(initializeModels, 1000); // 1ì´ˆ í›„ ëª¨ë¸ ë¡œë”© ì‹œì‘
        });

        clearBtn.addEventListener('click', () => {
            currentImage = null;
            processedImageData = null;
            imagePreview.innerHTML = '';
            resultArea.value = '';
            fileInput.value = '';
            processBtn.disabled = true;
            copyBtn.disabled = true;
            downloadBtn.disabled = true;
            loadingArea.style.display = 'none';
            resultArea.style.display = 'block';
            preprocessingOptions.style.display = 'none';
            previewCanvas.style.display = 'none';
        });

        copyBtn.addEventListener('click', async () => {
            if (resultArea.value) {
                try {
                    await navigator.clipboard.writeText(resultArea.value);
                    copyBtn.textContent = 'âœ… ë³µì‚¬ë¨!';
                    setTimeout(() => {
                        copyBtn.textContent = 'ğŸ“‹ ë³µì‚¬í•˜ê¸°';
                    }, 2000);
                } catch (err) {
                    // í´ë¦½ë³´ë“œ API ì‹¤íŒ¨ ì‹œ fallback
                    resultArea.select();
                    document.execCommand('copy');
                    copyBtn.textContent = 'âœ… ë³µì‚¬ë¨!';
                    setTimeout(() => {
                        copyBtn.textContent = 'ğŸ“‹ ë³µì‚¬í•˜ê¸°';
                    }, 2000);
                }
            }
        });

        downloadBtn.addEventListener('click', () => {
            if (resultArea.value) {
                const blob = new Blob([resultArea.value], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `ì¶”ì¶œëœí…ìŠ¤íŠ¸_${new Date().toLocaleDateString('ko-KR')}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'v':
                        // Ctrl+Vë¡œ í´ë¦½ë³´ë“œ ì´ë¯¸ì§€ ë¶™ì—¬ë„£ê¸°
                        e.preventDefault();
                        navigator.clipboard.read().then(items => {
                            for (let item of items) {
                                if (item.types.includes('image/png') || item.types.includes('image/jpeg')) {
                                    item.getType('image/png').then(blob => {
                                        handleFile(blob);
                                    });
                                    break;
                                }
                            }
                        }).catch(err => {
                            console.log('í´ë¦½ë³´ë“œ ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.');
                        });
                        break;
                    case 'Enter':
                        if (!processBtn.disabled) {
                            e.preventDefault();
                            processBtn.click();
                        }
                        break;
                }
            }
        });
    </script>
</body>
</html>